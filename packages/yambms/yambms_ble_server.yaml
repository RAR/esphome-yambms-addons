# Updated : 2026.02.17
# Version : 2.0.0
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

# +--------------------------------------+
# | YamBMS BLE Server                    |
# +--------------------------------------+
# Exposes YamBMS combined data as BLE server for wireless inverter proxy.
#
# ARCHITECTURE (v2.0 - Packed Characteristics):
# One service with 4 packed characteristics instead of 4 services
# with 23 individual characteristics. This avoids BLE notification
# subscription limits on the client side.
#
# Service UUID: 00000001-ba5e-f4ee-5ca1-eb1e5e4b1ce0
#
# Characteristic UUIDs:
#   00001001-...-eb1e5e4b1ce0 - Battery Core (28 bytes)
#   00001002-...-eb1e5e4b1ce0 - Limits (12 bytes)
#   00001003-...-eb1e5e4b1ce0 - Cells & Temperature (12 bytes)
#   00001004-...-eb1e5e4b1ce0 - Status & Alarms (16 bytes)

substitutions:
  ble_service_uuid: '00000001-ba5e-f4ee-5ca1-eb1e5e4b1ce0'

globals:
  - id: ${yambms_id}_ble_client_connected
    type: int
    restore_value: no
    initial_value: "0"

esp32_ble_server:
  manufacturer: "YamBMS"
  model: "BLE Proxy Server"
  on_connect:
    - lambda: |-
        id(${yambms_id}_ble_client_connected)++;
        ESP_LOGI("ble_server", "Client connected (total: %d)", id(${yambms_id}_ble_client_connected));
  on_disconnect:
    - lambda: |-
        if (id(${yambms_id}_ble_client_connected) > 0) id(${yambms_id}_ble_client_connected)--;
        ESP_LOGI("ble_server", "Client disconnected (remaining: %d)", id(${yambms_id}_ble_client_connected));

  services:
    - uuid: ${ble_service_uuid}
      advertise: true
      characteristics:
        # ------------------------------------------
        # CHARACTERISTIC 1: BATTERY CORE (28 bytes)
        # ------------------------------------------
        #   [0-3]:   voltage (uint32_t LE, mV)
        #   [4-7]:   current (int32_t LE, mA)
        #   [8-11]:  power (int32_t LE, mW)
        #   [12-13]: soc (uint16_t LE, 0.1%)
        #   [14-15]: soh (uint16_t LE, 0.1%)
        #   [16-19]: capacity (uint32_t LE, mAh)
        #   [20-23]: capacity_remaining (uint32_t LE, mAh)
        #   [24-27]: charging_cycles (uint32_t LE)
        - id: ble_char_battery
          uuid: '00001001-ba5e-f4ee-5ca1-eb1e5e4b1ce0'
          description: 'Battery Core'
          read: true
          notify: true
          value:
            data: !lambda |-
              auto pack_u32 = [](std::vector<uint8_t>& v, uint32_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
                v.push_back((val >> 16) & 0xFF);
                v.push_back((val >> 24) & 0xFF);
              };
              auto pack_i32 = [](std::vector<uint8_t>& v, int32_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
                v.push_back((val >> 16) & 0xFF);
                v.push_back((val >> 24) & 0xFF);
              };
              auto pack_u16 = [](std::vector<uint8_t>& v, uint16_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
              };
              auto safe = [](float val, float def = 0.0f) {
                return std::isnan(val) ? def : val;
              };
              
              std::vector<uint8_t> data;
              data.reserve(28);
              
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_total_voltage).state) * 1000));
              pack_i32(data, static_cast<int32_t>(safe(id(${yambms_id}_current).state) * 1000));
              pack_i32(data, static_cast<int32_t>(safe(id(${yambms_id}_power).state) * 1000));
              pack_u16(data, static_cast<uint16_t>(safe(id(${yambms_id}_battery_soc).state) * 10));
              pack_u16(data, static_cast<uint16_t>(safe(id(${yambms_id}_battery_soh).state) * 10));
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_installed_battery_capacity).state) * 1000));
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_battery_capacity_remaining).state) * 1000));
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_charging_cycles).state)));
              
              return data;

        # ------------------------------------------
        # CHARACTERISTIC 2: LIMITS (12 bytes)
        # ------------------------------------------
        #   [0-3]:   charge_voltage CVL (uint32_t LE, mV)
        #   [4-5]:   charge_current CCL (uint16_t LE, 0.1A)
        #   [6-9]:   discharge_voltage DVL (uint32_t LE, mV)
        #   [10-11]: discharge_current DCL (uint16_t LE, 0.1A)
        - id: ble_char_limits
          uuid: '00001002-ba5e-f4ee-5ca1-eb1e5e4b1ce0'
          description: 'Limits'
          read: true
          notify: true
          value:
            data: !lambda |-
              auto pack_u32 = [](std::vector<uint8_t>& v, uint32_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
                v.push_back((val >> 16) & 0xFF);
                v.push_back((val >> 24) & 0xFF);
              };
              auto pack_u16 = [](std::vector<uint8_t>& v, uint16_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
              };
              auto safe = [](float val, float def = 0.0f) {
                return std::isnan(val) ? def : val;
              };
              
              std::vector<uint8_t> data;
              data.reserve(12);
              
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_requested_charge_voltage).state) * 1000));
              pack_u16(data, static_cast<uint16_t>(safe(id(${yambms_id}_requested_charge_current).state) * 10));
              pack_u32(data, static_cast<uint32_t>(safe(id(${yambms_id}_requested_discharge_voltage).state) * 1000));
              pack_u16(data, static_cast<uint16_t>(safe(id(${yambms_id}_requested_discharge_current).state) * 10));
              
              return data;

        # ------------------------------------------
        # CHARACTERISTIC 3: CELLS & TEMP (12 bytes)
        # ------------------------------------------
        #   [0-1]:   cell_count (uint16_t LE)
        #   [2-3]:   min_cell_voltage (uint16_t LE, mV)
        #   [4-5]:   max_cell_voltage (uint16_t LE, mV)
        #   [6-7]:   delta_cell_voltage (uint16_t LE, mV)
        #   [8-9]:   min_temperature (int16_t LE, 0.1°C)
        #   [10-11]: max_temperature (int16_t LE, 0.1°C)
        - id: ble_char_cells
          uuid: '00001003-ba5e-f4ee-5ca1-eb1e5e4b1ce0'
          description: 'Cells and Temperature'
          read: true
          notify: true
          value:
            data: !lambda |-
              auto safe = [](float val, float def = 0.0f) {
                return std::isnan(val) ? def : val;
              };
              auto safe_temp = [](float val) -> int16_t {
                if (std::isnan(val)) return -2730;
                return static_cast<int16_t>(val * 10);
              };
              
              uint16_t cell_count = static_cast<uint16_t>(safe(id(${yambms_id}_cell_count).state));
              uint16_t min_cv = static_cast<uint16_t>(safe(id(${yambms_id}_min_cell_voltage).state) * 1000);
              uint16_t max_cv = static_cast<uint16_t>(safe(id(${yambms_id}_max_cell_voltage).state) * 1000);
              uint16_t delta = static_cast<uint16_t>(safe(id(${yambms_id}_delta_cell_voltage).state) * 1000);
              int16_t min_t = safe_temp(id(${yambms_id}_min_temperature).state);
              int16_t max_t = safe_temp(id(${yambms_id}_max_temperature).state);
              
              return std::vector<uint8_t>{
                static_cast<uint8_t>(cell_count & 0xFF), static_cast<uint8_t>((cell_count >> 8) & 0xFF),
                static_cast<uint8_t>(min_cv & 0xFF), static_cast<uint8_t>((min_cv >> 8) & 0xFF),
                static_cast<uint8_t>(max_cv & 0xFF), static_cast<uint8_t>((max_cv >> 8) & 0xFF),
                static_cast<uint8_t>(delta & 0xFF), static_cast<uint8_t>((delta >> 8) & 0xFF),
                static_cast<uint8_t>(min_t & 0xFF), static_cast<uint8_t>((min_t >> 8) & 0xFF),
                static_cast<uint8_t>(max_t & 0xFF), static_cast<uint8_t>((max_t >> 8) & 0xFF)
              };

        # ------------------------------------------
        # CHARACTERISTIC 4: STATUS & ALARMS (16 bytes)
        # ------------------------------------------
        #   [0-3]:   status_flags (uint32_t LE, bitfield)
        #              Bit 0: Charge enabled
        #              Bit 1: Discharge enabled
        #              Bit 2: Equalizing
        #              Bit 3: Force charge requested
        #   [4-5]:   errors_alarm (uint16_t LE)
        #   [6-7]:   errors_warning (uint16_t LE)
        #   [8-11]:  bms_combined (uint32_t LE, count)
        #   [12-15]: heartbeat (uint32_t LE, counter)
        - id: ble_char_status
          uuid: '00001004-ba5e-f4ee-5ca1-eb1e5e4b1ce0'
          description: 'Status and Alarms'
          read: true
          notify: true
          value:
            data: !lambda |-
              auto pack_u32 = [](std::vector<uint8_t>& v, uint32_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
                v.push_back((val >> 16) & 0xFF);
                v.push_back((val >> 24) & 0xFF);
              };
              auto pack_u16 = [](std::vector<uint8_t>& v, uint16_t val) {
                v.push_back(val & 0xFF);
                v.push_back((val >> 8) & 0xFF);
              };
              
              // Status flags bitfield
              uint32_t flags = 0;
              std::string ci = id(${yambms_id}_charging_instruction).state;
              if (ci == "Bulk" || ci == "Float") flags |= (1 << 0);
              if (id(${yambms_id}_discharging_instruction).state) flags |= (1 << 1);
              if (id(${yambms_id}_equalizing).state) flags |= (1 << 2);
              if (id(${yambms_id}_requested_force_charge).state) flags |= (1 << 3);
              
              // Errors
              uint16_t alarm = 0, warning = 0;
              float a = id(${yambms_id}_errors_bitmask_alarm).state;
              float w = id(${yambms_id}_errors_bitmask_warning).state;
              if (!std::isnan(a)) alarm = static_cast<uint16_t>(a);
              if (!std::isnan(w)) warning = static_cast<uint16_t>(w);
              
              // BMS combined count
              uint32_t combined = static_cast<uint32_t>(id(${yambms_id}_bms_combined).state);
              
              // Heartbeat
              static uint32_t counter = 0;
              counter++;
              
              std::vector<uint8_t> data;
              data.reserve(16);
              
              pack_u32(data, flags);
              pack_u16(data, alarm);
              pack_u16(data, warning);
              pack_u32(data, combined);
              pack_u32(data, counter);
              
              return data;

# +----------------------------------------------+
# | Notify all characteristics periodically      |
# +----------------------------------------------+
interval:
  - interval: 5s
    then:
      - if:
          condition:
            lambda: 'return id(${yambms_id}_ble_client_connected);'
          then:
            - ble_server.characteristic.notify: { id: ble_char_battery }
            - ble_server.characteristic.notify: { id: ble_char_limits }
            - ble_server.characteristic.notify: { id: ble_char_cells }
            - ble_server.characteristic.notify: { id: ble_char_status }
